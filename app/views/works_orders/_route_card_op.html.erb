<%# views/works_orders/_route_card_op.html.erb %>
<%# Render individual operation %>
<%
  has_variables = op[:all_variables]&.length&.> 0 || false
  top_style = has_variables ? 'border-bottom-style: dashed;' : ''
  bottom_style = has_variables ? 'border-top-style: dashed;' : ''
  rowspan = has_variables ? 2 : 1
  is_op_1 = op[:number] == 1

  # Parse operation content to extract OCV batches and test result lines
  main_content = []
  ocv_batches = []
  test_results = []
  in_ocv_section = false

  if op[:content]
    op[:content].each do |item|
      if item[:type] == "paragraph"
        text = item[:as_html] || ""

        # Split by newlines to process line by line
        lines = text.split(/\n/)

        lines.each do |line|
          # Check if this line contains OCV monitoring header (with or without bold)
          if line.match(/\*{0,2}OCV Monitoring:\*{0,2}/i)
            in_ocv_section = true
            next # Skip the header line itself
          end

          # Check for inline OCV monitoring format: *OCV monitoring; Batch ...*
          if line.match(/\*OCV monitoring;.*Batch.*\*/i)
            batch_match = line.match(/\*OCV monitoring;\s*(Batch.*?)\*/)
            if batch_match
              ocv_batches << batch_match[1].strip
              line = line.gsub(/\*OCV monitoring;.*?\*/, '').strip
              main_content << line unless line.empty?
              next
            end
          end

          # Check for inline OCV monitoring with colon: **OCV Monitoring:** Batch (no semicolon, no wrapping asterisks)
          if line.match(/\*\*OCV Monitoring:\*\*\s+Batch/i)
            # Extract content before OCV monitoring
            before_match = line.match(/^(.*?)\s*\*\*OCV Monitoring:\*\*/i)
            if before_match
              pre_ocv_text = before_match[1].strip
              main_content << pre_ocv_text unless pre_ocv_text.empty?
            end

            # Extract all batches from the rest of the line
            ocv_part = line.sub(/^.*?\*\*OCV Monitoring:\*\*/i, '').strip
            # Split by "Batch" and reconstruct each batch line
            batch_segments = ocv_part.split(/(?=Batch\s+___:)/)
            batch_segments.each do |segment|
              segment = segment.strip
              next if segment.empty?
              ocv_batches << segment if segment.start_with?('Batch')
            end
            next
          end

          # Check if line contains any "Batch X:" pattern
          if line.match(/Batch\s+(?:___|[0-9]+):/)
            # Check if it starts with Batch (separate line format)
            if line.strip.match(/^Batch\s+(?:___|[0-9]+):/)
              ocv_batches << line.strip
            else
              # Embedded batch format
              # Extract text before any batch
              before_match = line.match(/^(.*?)Batch\s+(?:___|[0-9]+):/)
              if before_match
                pre_batch_text = before_match[1].strip
                main_content << pre_batch_text unless pre_batch_text.empty?
              end

              # Extract all batches using scan with negative lookahead
              # Pattern captures: "Batch X: [anything that's not the start of another Batch or **CapitalLetter]"
              batch_matches = line.scan(/(Batch\s+(?:___|[0-9]+):\s*(?:(?!Batch\s+(?:___|[0-9]+):|\*\*[A-Z]).)*?)(?=Batch\s+(?:___|[0-9]+):|\*\*[A-Z]|$)/m)

              batch_matches.each do |match|
                batch_text = match[0].strip
                ocv_batches << batch_text unless batch_text.empty?
              end

              # Extract content after all batches (like **Measured Film Thickness**)
              after_batches_match = line.match(/Batch\s+(?:___|[0-9]+):[^*]*?(\*\*[A-Z].*$)/)
              if after_batches_match
                post_batch_text = after_batches_match[1].strip
                main_content << post_batch_text unless post_batch_text.empty?
              end
            end
          # Check if this line is a test result line (A), B), C), etc.)
          elsif line.strip.match(/^[A-F]\)/)
            test_results << line.strip
          else
            # Regular content line
            main_content << line unless line.strip.empty? && in_ocv_section
          end
        end
      end
    end
  end

  # Reconstruct main content HTML
  main_html = main_content.join("\n")
%>

<tr class="op op-<%= op[:number] %>">
  <td rowspan="<%= rowspan %>">
    <%= op[:number] %>
  </td>
  <td style="<%= top_style %>">
    <%= main_html.html_safe %>

    <% if test_results.any? %>
      <div class="ocv-section">
        <div class="ocv-header">Test Results:</div>
        <% test_results.each do |result| %>
          <div class="ocv-batch-card">
            <%= result.html_safe %>
          </div>
        <% end %>
      </div>
    <% end %>

    <% if ocv_batches.any? %>
      <div class="ocv-section">
        <div class="ocv-header">OCV Monitoring:</div>
        <% ocv_batches.each do |batch| %>
          <div class="ocv-batch-card">
            <%= batch.html_safe %>
          </div>
        <% end %>
      </div>
    <% end %>
  </td>

  <% if is_op_1 %>
    <!-- For OP 1, merge all batch columns into one -->
    <td colspan="<%= batch_cols %>" style="<%= top_style %>"></td>
  <% else %>
    <!-- For all other operations, use separate columns -->
    <% batch_cols.times do %>
      <td style="<%= top_style %>"></td>
    <% end %>
  <% end %>
</tr>

<% if has_variables %>
  <tr>
    <td style="<%= bottom_style %>">
      <% op[:all_variables].each do |variable| %>
        <div class="variable-row" style="font-weight:bold; text-align: right;">
          <span class="variable-name"><%= variable[:as_html]&.html_safe %></span>:
        </div>
      <% end %>
    </td>

    <% if is_op_1 %>
      <!-- For OP 1, merge all batch columns into one -->
      <td colspan="<%= batch_cols %>" style="<%= bottom_style %>"></td>
    <% else %>
      <!-- For all other operations, use separate columns -->
      <% batch_cols.times do %>
        <td style="<%= bottom_style %>"></td>
      <% end %>
    <% end %>
  </tr>
<% end %>
